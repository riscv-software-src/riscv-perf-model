:doctitle: Olympia Vector Permutation Design Document

:toc:

[[Document_Information]]
== Document Information

TODO

[[Revision_History]]
=== Revision History

[width="100%",cols="11%,11%,16%,62%",options="header",]
|===
|*Revision* |*Date*      |*Author*  |*Summary of Changes*
|0.1        | 2025.04.TODO | Sai Govardhan | Initial Vector Permutations 
Design Document
|===

[[Conventions_and_Terminology]]
=== Conventions and Terminology


[width="100%",cols="17%,83%",options="header",]
|===
|Label |Description
| VLSU | Vector Load Store Unit
| VLEN | Vector Register Length (1024 bits in Olympia)
| SEW  | Selected Element Width
| LMUL | Vector Register Group Multiplier
| ELEN | Maximum Vector Element Width
| VTA  | Vector Tail Agnostic
// TODO MORE
|===
[[Related_Documents]]
=== Related Documents

// <external documents relevant to the unit>

[width="100%",cols="25%,75%",options="header",]
|===
|*Title* |*Description*
| The RISC-V Vector ISA (v1.0) | TODO 
// | Saturn Vectors | TODO
// | The vector thesis | TODO
// Cray reference?
// Chipsalliance T1? 
// Tenstorrent Ocelot?
// Barcaelona Supercomputing Group slides?
|===

[[Notes_Open_Issues]]
=== Notes/Open Issues

// <advisories, limitations, unsolved problems>

* Note1
* Note 2

[[OVERVIEW]]
== OVERVIEW
The following is the directory structure of olympia, for reference:

```bash
.
├── arches              
├── CMakeLists.txt
├── CodingStyle.md
├── conda
├── CONTRIBUTING.md
├── CONTRIBUTORS.md
├── core                ## Consists of the vector/ directory
├── docs
├── fsl
├── layouts
├── LICENSE
├── mavis
├── mss
├── README.md
├── release
├── reports
├── sim
├── stf_lib
├── test
├── test.json
└── traces
```

We shall implement the Vector Permutation instructions in the `core/vector/`, make some modifications to the `core/InstGenerator.cpp` and run tests in the `test/core/vector/` directory. The following document lists down the instructions we have implemented, the changes we have made to the existing files and the architecture of these new vector perumute implementations.

=== Configuring the Vector Unit 

Olympia implements the Vector Unit in the `core/vector/` directory where:

 - `VLEN` is the width of the vector register statically set to 1024

 - `ELEN`, the Maximum Vector Element Width is specified based on `sew_` 
 (Set Element Width)

Within the `core/vector/VectorConfig.hpp` file, the `VectorConfig` class is 
defined to configure the Vector Unit.

```
VectorConfig(uint32_t vl, uint32_t sew, uint32_t lmul, uint32_t vta)
```

A sample assembly instruction is:

```
vsetvli t0, a0, e32, m1   # Configure vector unit where a0 specifies the vector 
length (vl_), sew_=32, lmul_=1

```
Note that the Vector register group multiplier setting is specified by `lmul_` 
and is set to 1 by default. 

The `vlmax_`, the maximum vector length is set to `((VLEN / sew_) * lmul_)`.

We would be using a subset of `vlmax_` by specifying the `vl_` in the vector 
configuration.

Take an example where VLEN is set to 1024, `sew_` is 32 bits and `lmul_` is 1. 
Then `vlmax_` is ((1024/32)*1) = 32. Which means that there is one logical 
Vector register is divided into 32 elements of 32 bits each.

If we set Vector Length (that we would use) `vl_` to 16, then we are using 16 
elements of 32 `vlmax_` elements we could use in the logical vector register 
file instance.

Note that the `vta_` (Vector Tail Agnostic) parameter is set to false by 
default, which indicates that it is undisturbed. 


// <Overview of the unit, what does it do, where does it fit into Olympia
// proper, use the section below to discuss the context>

=== How are the Vector Uops generated?

We decode and determine the instructions as Vector instructions in the 
`core/decode/Decode.cpp` file using Mavis as specified in the 
`mavis/json/isa_rv64v.json` and the `mavis/json/isa_rv64vf.json` files for both
the Base Vector instructions and the Vector Floating Point instructions.

The `core/vector/VectorUopGenerator.hpp` file implements the Vector Uop 
Generator. 

Note that we currently hardcode the `lmul_` parameter to 1 in the above
configuration, which implies that each vector instruction currently generates 
only one micro-operation. 

### Adding Support to Vector Permutation instructions

- Instruction Architecture Info:
    
    . `core/InstArchInfo.hpp`:
        .. Already has `VPERMUTE` in TargetPipe enum
        .. Need to ensure proper UopGenType for permutation, to add: 
            ... `SCALAR_MOVE`
            ... `SLIDE1UP`
            ... `SLIDE1DOWN`
            ... `SLIDEUP`
            ... `SLIDEDOWN`
            ... `RGATHER`
            ... `COMPRESS` 
        
    . `mavis/json/isa_rv64v.json`:
        .. Define vector permutation instruction encodings
        .. Specify operand types and fields
    
    . `core/execute/IssueQueue.hpp`:
        .. Configure scheduler for vector permute operations
    
    . `core/execute/Execute.cpp`:
        .. Handle execution of permute operations
    
    . `core/vector/VectorConfig.hpp`:
        .. Already has basic vector config (VLEN, SEW, LMUL)
        .. May need updates for permute-specific settings
    
The files we shall be modifying: 

. `core/InstArchInfo.hpp` 
    - UopGenType to be updated to specific implementations of Vector Permutation instructions, to remove the `PERMUTE` entry

. `core/vector/VectorUopGenerator.hpp` 
    - Currently has stub for `generatePermuteUops_`

. `core/vector/VectorUopGenerator.cpp`  
    - Add implementation for specific permutation ops and replace `generatePermuteUops_`

```cpp
        uop_gen_function_map_.emplace(InstArchInfo::UopGenType::PERMUTE,
                                      &VectorUopGenerator::generatePermuteUops_);
```

. `test/core/vector/Vector_test.cpp`:
    - Add test cases for vector permutation instructions


#### List of all the Vector Permutation Instructions to be implemented:

##### Vector Scalar Move Instructions

    . vmv.x.s rd, vs2    # x[rd] = vs2[0]
    . vmv.s.x vd, rs1    # vd[0] = x[rs1]

Key points:

    - Ignores LMUL and vector register groups
    - Operates even if vstart ≥ vl or vl=0
    - Handles SEW vs XLEN width differences

// - TODO MORE


##### Vector Slide Instructions
    
    . vslideup.vx/vi    # vd[i+OFFSET] = vs2[i]
    . vslidedown.vx/vi  # vd[i] = vs2[i+OFFSET]
    . vslide1up.vx      # vd[0]=x[rs1], vd[i+1]=vs2[i]
    . vslide1down.vx    # vd[i]=vs2[i+1], vd[vl-1]=x[rs1]

Critical behaviors:
    
    - No operation if vstart ≥ vl
    - Follows tail/mask policies
    - Source/dest register groups cannot overlap
    - OFFSET from x-reg or immediatte
// - TODO MORE

##### Vector Register Gather

    . vrgather.vv vd, vs2, vs1, vm          # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
    . vrgatherei16.vv vd, vs2, vs1, vm      # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
    . vrgather.vx vd, vs2, rs1, vm          # vd[i] = (x[rs1] >= VLMAX) ? 0 : vs2[x[rs1]]
    . vrgather.vi vd, vs2, uimm, vm         # vd[i] = (uimm >= VLMAX) ? 0 : vs2[uimm]

Requirements:

    - Out-of-range indices return 0
    - No source/dest overlap allowed
    - Handles different element widths
// - TODO MORE

##### Vector Compress

    . vcompress.vm      # Pack masked elements contiguously

[[Overview_Block_Diagram]]
=== Overview Block Diagram

// <Add an overview block diagram>
. TODO

[[Functional_Description]]
== Functional Description

// <this begins the detailed description of the unit. Typically, this
// discusses each major block in a separate sub-section>
. TODO

[[Unit_Block_Diagram]]
=== Unit Block Diagram

// <Add an overview block diagram>
// image:media/image1.png[image,width=576,height=366]
// Figure 1 - Sample Figure
. TODO


[[Block_Diagram_Description]]
=== Block Diagram Description

// <walk through the block diagram>

// [[Description_of_Block_B1]]
// == Description of Block <B1>

// <this section contains block level details>
. TODO

[[Operation]]
=== Operation

// <describe the low-level operation of the block>
. TODO

[[Interfaces]]
=== Interfaces

// <this is typically a general list of block interfaces, this changes with
// development, final design will finalize this section>
. TODO

[width="100%",cols="18%,21%,61%",options="header",]
|===
|*Name* |*C++ Type* |*Purpose/Description*
| | |
| | |
| | |
|===

[[CPP_Class_Description]]
=== C++ Class Description

// <describe the class, it’s inheritance assumptions and data structures
// used by the class
. TODO

[[Parameterization]]
=== Parameterization

// <top level parameterization, include hidden and those visible in arch
// yaml>
. TODO

[[Test_Bench_Description]]
== Test Bench Description

// <description of what is covered by the test bench, description of each
// test as appropriate
. TODO

[[Description_of_Test_1]]
=== Description of Test 1

// <discuss test 1>
. TODO

[[Description_of_Test_2]]
=== Description of Test 2

// <discuss test 2>
. TODO

[[Future_Work_or_Features]]
== Future Work or Features

// <forward looking statements>
. TODO

[[References_Citations]]
== References/Citations

// <Add references as needed>
// [1] <insert citation>
. TODO

[[Appendices]]
== Appendices

// <as needed>
. TODO

[[Appendix_1]]
=== Appendix 1

// <as needed>
. TODO
